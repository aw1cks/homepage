<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Alex Wicks"><meta name=description content="Automated provisioning of hardware"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lazy Hardware Provisioning"><meta name=twitter:description content="Automated provisioning of hardware"><meta property="og:title" content="Lazy Hardware Provisioning"><meta property="og:description" content="Automated provisioning of hardware"><meta property="og:type" content="article"><meta property="og:url" content="https://awicks.io/posts/lazy-hardware-provisioning/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-15T00:00:00+00:00"><meta property="article:modified_time" content="2022-04-15T00:00:00+00:00"><title>Lazy Hardware Provisioning · Alex Wicks</title><link rel=canonical href=https://awicks.io/posts/lazy-hardware-provisioning/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css integrity="sha256-2f3b/+byfmmYXcX+BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/favicon_32x32.png sizes=32x32><link rel=icon type=image/png href=/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><meta name=generator content="Hugo 0.97.3"></head><body class="preload-transitions colorscheme-dark"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Alex Wicks</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=https://cv.awicks.io>Curriculum Vitae</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://awicks.io/posts/lazy-hardware-provisioning/>Lazy Hardware Provisioning</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-04-15T00:00:00Z>2022-04-15</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
8-minute read</span></div></div></header><div><p>Don&rsquo;t you ever find it annoying setting up your new laptop for the <em>nth time</em>? You always inevitably forget that one package which you need when you&rsquo;re in the middle of something, and it&rsquo;s never quite the same as the last install. Not to mention the time wasted - for me at least, it&rsquo;s normally a whole day set aside. Seeing as I like to automate things, this wasn&rsquo;t going to cut it.</p><p>None of what is mentioned here are novel concepts - solutions such as <a href=https://tinkerbell.org/>Tinkerbell</a> have existed for a while. But who wants all that infrastructure for an ad-hoc build at home?</p><h2 id=packer>Packer
<a class=heading-link href=#packer><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Enter <a href=https://www.packer.io/>Hashicorp Packer</a>, a tool primarily designed for building VM templates.</p><p>But wait, you ask, how does this help me with my laptop? I don&rsquo;t want a VM!</p><h2 id=whats-the-difference-anyway>What&rsquo;s the difference anyway?
<a class=heading-link href=#whats-the-difference-anyway><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Although we might think of a VM as being a poor approximation of a real piece of hardware, long gone are the days of old with Windows driver hell. In fact, for the longest time people have been picking up their Linux install from one machine and copying it verbatim to another. So why not the same concept from a VM onto our bare metal? After all, the vast majority of drivers you&rsquo;d ever need are in the kernel tree and included as modules by your distro in all likelihood.</p><h2 id=qemu-to-the-rescue>QEMU to the rescue
<a class=heading-link href=#qemu-to-the-rescue><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Packer has a great <a href=https://www.packer.io/plugins/builders/qemu>QEMU builder</a>, with a rich plugin system allowing us to add arbitrary steps before & after the image build. Any recent kernel and somewhat recent CPU will have the relevant hardware acceleration support in the form of KVM & Intel&rsquo;s VT-x or AMD&rsquo;s SVM respectively. QEMU itself is available on pretty much any distro, and can run inside a privileged Docker container in a pinch.</p><h2 id=how-on-earth-does-this-work>How on earth does this work?
<a class=heading-link href=#how-on-earth-does-this-work><i class="fa fa-link" aria-hidden=true></i></a></h2><p>In a lot of cases where you&rsquo;re using Packer, you&rsquo;ll already have the luxury of a base image, such an AWS AMI that&rsquo;s already been provided, where you just want to add some customisations. In our case, we&rsquo;re not so lucky. And since I am using Arch Linux, the process is a little convoluted&mldr; [1]</p><h3 id=preparing-the-environment>Preparing the environment
<a class=heading-link href=#preparing-the-environment><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Just like doing it all by hand, we&rsquo;re booting into an Arch Linux live environment, where we are dropped into a shell. Except we want to run all the commands automatically. As such we need to setup the SSH communicator that Packer will be expecting. Luckily, the QEMU builder supports the <code>boot_command</code> directive, which allows us to enter a string which will then get typed on the keyboard.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span>boot_command <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;&lt;enter&gt;&lt;wait20s&gt;&lt;enter&gt;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;/usr/bin/curl -O http://{{ .HTTPIP }}:{{ .HTTPPort }}/prepare.sh&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;&lt;enter&gt;&lt;wait2s&gt;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;/usr/bin/curl -O http://{{ .HTTPIP }}:{{ .HTTPPort }}/inst_liveboot.sh&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;&lt;enter&gt;&lt;wait2s&gt;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;/usr/bin/curl -O http://{{ .HTTPIP }}:{{ .HTTPPort }}/dd.py&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;&lt;enter&gt;&lt;wait2s&gt;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;/usr/bin/curl -O http://{{ .HTTPIP }}:{{ .HTTPPort }}/seed.iso&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;&lt;enter&gt;&lt;wait2s&gt;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;/bin/sh ./prepare.sh&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;&lt;enter&gt;&#34;</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><h4 id=dissecting-the-boot-command>Dissecting the boot command
<a class=heading-link href=#dissecting-the-boot-command><i class="fa fa-link" aria-hidden=true></i></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#e6db74>&#34;&lt;enter&gt;&lt;wait20s&gt;&lt;enter&gt;&#34;</span>,
</span></span></code></pre></div><p>The values inside angle brackets are interpreted by Packer as escape sequences. At the beginning we are hitting enter to pass the bootloader screen, waiting for the live boot to finish booting for 20 seconds, then hitting enter again to make the auto-login worked fine and we have a clean shell ready for our commands.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#e6db74>&#34;/usr/bin/curl -O http://{{ .HTTPIP }}:{{ .HTTPPort }}/prepare.sh&#34;</span>,
</span></span></code></pre></div><p>Packer will handily serve a directory via its inbuilt HTTP server, if desired. Anything inside double curly braces is a template variable, and will be populated with the actual value by Packer. As such, I can place a simple script in my HTTP directory to configure SSH:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;root:init&#39;</span> | chpasswd -c SHA512
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;PermitRootLogin yes&#39;</span> &gt;&gt; /etc/ssh/sshd_config
</span></span><span style=display:flex><span>systemctl restart sshd
</span></span></code></pre></div><p>And rinse and repeat for any other files I may need in my bootstrapping environment.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span> <span style=color:#e6db74>&#34;/bin/sh ./prepare.sh&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;&lt;enter&gt;&#34;</span>
</span></span></code></pre></div><p>Great - now we have all our files in place! Let&rsquo;s run our script so we can get the SSH communicator working.</p><h4 id=putting-the-ssh-communicator-to-use>Putting the SSH communicator to use
<a class=heading-link href=#putting-the-ssh-communicator-to-use><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Packer has some neat provisioning plugins we can use, now that we have a channel of communication to the guest, such as the Ansible provisioner.
For our use case though, the shell provisioner should be sufficient. Note that it will copy the file onto the guest for you, no manual steps required.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>provisioner</span> <span style=color:#e6db74>&#34;shell&#34;</span> {
</span></span><span style=display:flex><span>  script <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;packer/bootstrap_liveboot.sh&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From this point onwards, we just want to configure an Arch Linux system the way we want - partition the disk, make the filesystems, mount them under <code>/mnt</code>, run <code>pacstrap</code> to install the base system including any useful tools that might be needed (we&rsquo;ll touch on this later), generate the fstab file. All the usual stuff. With one twist&mldr;</p><h4 id=chroot-environment>Chroot environment
<a class=heading-link href=#chroot-environment><i class="fa fa-link" aria-hidden=true></i></a></h4><p>In a normal Arch Linux install, once you&rsquo;ve installed & configured the base system, you would run <code>arch-chroot</code> which mounts the relevant bind mounts & chroots into the new system on your mount point. Except this doesn&rsquo;t work for us, since it won&rsquo;t allow us to run a script non-interactively. As such, we use a feature of systemd called <a href=https://www.freedesktop.org/software/systemd/man/systemd-nspawn.html>systemd-nspawn</a> which is somewhat analagous to Docker, but using our filesystem on the disk as our &lsquo;image&rsquo;.</p><p>First off, we need to copy any files needed <em>inside</em> the new root:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#66d9ef>for</span> FILE in inst.sh postinst.sh
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  cp <span style=color:#e6db74>&#34;/root/</span><span style=color:#e6db74>${</span>FILE<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> /mnt
</span></span><span style=display:flex><span>  chmod +x <span style=color:#e6db74>&#34;/mnt/</span><span style=color:#e6db74>${</span>FILE<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>Now we can fire off systemd-nspawn, with our &rsquo;entrypoint&rsquo; being a script of our choosing which will be non-interactively executed inside our container environment, passing any relevant arguments you may want:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>systemd-nspawn <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -D /mnt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  /inst.sh <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>CRYPT_PASSWD<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>blkid -s UUID -o value <span style=color:#e6db74>&#34;/dev/disk/by-partlabel/</span><span style=color:#e6db74>${</span>ROOT_PARTLABEL<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>Note how the path to the executable is now relative to the chrooted <code>/mnt</code> (i.e. if the file is at <code>/mnt/inst.sh</code>, since we chroot, that becomes <code>/inst.sh</code>).</p><p>Again, inside this script, you can configure your system however you like. Note that this environment will be a virtual machine, so don&rsquo;t rely on trying to detect what GPU is installed so you can install the right drivers, for example.</p><p>Once this finishes, you&rsquo;ll have a base image, very much like what an AWS AMI would be.</p><h3 id=ok-i-have-my-image---now-what>OK, I have my image - now what?
<a class=heading-link href=#ok-i-have-my-image---now-what><i class="fa fa-link" aria-hidden=true></i></a></h3><p>What degree do you want to go to? The simplest thing here is to take the image we just created, and <code>dd</code> it directly onto your laptop&rsquo;s disk from a live boot.</p><p>But that&rsquo;s not good enough for me. Time for image-ception&mldr;</p><h3 id=building-a-custom-liveboot>Building a custom liveboot
<a class=heading-link href=#building-a-custom-liveboot><i class="fa fa-link" aria-hidden=true></i></a></h3><p>To make life maximally easy, I build my own custom liveboot image, with the disk image we just created baked in. As soon as the livebooot starts, we run a python script which will prompt the user which disk they would like to write to, and then <code>dd</code> the disk image onto it. In addition, we will add some <code>cloud-init</code> configuration onto our liveboot USB stick, so that the machine can use this on first boot after copying the disk image across. This allows the machine to get its network configuration without me manually doing anything.</p><p>The process is much the same as before, using Packer to build another image which contains our first image and auto-launches the python script.</p><h3 id=cloud-init>cloud-init?
<a class=heading-link href=#cloud-init><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Cloud-init is another tool typically used to configure a cloud image at first boot. It talks to the cloud provider&rsquo;s metadata API to get some basic information about itself such as its hostname, as well as a user-provided file with any extra desired configuration (such as SSH keys). But we&rsquo;re not in a cloud environment - so what gives?</p><p>Well, cloud-init has a <a href=https://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html>NoCloud</a> data source. Which handily means we can inject our configuration using the same USB stick we put our liveboot onto, by simply creating a partition with the correct label that cloud-init looks for, and putting our config there.</p><p>Why do we want this, you may ask?</p><ul><li>It will grow the disk for us on first boot. Which is really handy, since we can then make the disk image only the size it needs to be, and grow it once copied onto the target disk automagically.</li><li>It will configure the network automatically. Which allows us to run other automatic scripts that require network connectivity.</li><li>We can trigger config management to run. In my case, I configure my whole system with Ansible, so it&rsquo;ll set up everything just how I like it, from installing all my packages down to even my dotfiles.</li></ul><h2 id=wrapping-up>Wrapping up
<a class=heading-link href=#wrapping-up><i class="fa fa-link" aria-hidden=true></i></a></h2><p>If you want to see an example, <a href=https://github.com/aw1cks/sloth>here&rsquo;s how I&rsquo;ve done it</a>.
All the ansible configuration is available <a href=https://github.com/archlinux-ansible/>here</a>.</p><p>Why not use nix, you might ask? Good question. I approached this as more of a learning exercise, which happened to be quite useful. I&rsquo;m not comfortable with nix nor do I see myself putting the time in to become proficient, so this works well for me.</p><p>All in all, I think this is a useful technique to increase reproducability, and it&rsquo;s quite useful for bootstrapping some infrastructure from zero quickly. It&rsquo;s not the best approach perhaps, but it only requires a USB stick and another PC.</p><h3 id=addendum>Addendum
<a class=heading-link href=#addendum><i class="fa fa-link" aria-hidden=true></i></a></h3><p>[1] In the time since I devised this method, <a href=https://wiki.archlinux.org/title/Archinstall>archinstall</a> was released, which would probably simplify this process.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2022
Alex Wicks
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.8fb86376a16e684af472a329aef502dbebcfab65ce264e9750d144912947c602.js integrity="sha256-j7hjdqFuaEr0cqMprvUC2+vPq2XOJk6XUNFEkSlHxgI="></script></body></html>